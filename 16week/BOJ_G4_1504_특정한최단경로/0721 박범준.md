# BOJ-G4-1504-특정한최단경로

[문제링크](https://www.acmicpc.net/problem/1504)

### 분류

그래프 이론<br>
데이크스트라<br>
최단 경로

### 접근법

1. 데이크스트라 알고리즘을 사용한다는 면에서 다른 유사문제와 똑같이 접근해서 크게 어렵지 않았다.
2. 다른점은 시작 정점에서 필수방문 정점들 까지의 거리를 계산하는 것이었다.
3. start -> v1 -> v2 -> n 그리고 start -> v2 -> v1 -> n 이렇게 두가지의 거리를 계산하고 더 작은값을 출력한다.

### Code

```python
import sys
input = sys.stdin.readline
import heapq


def dijkstra(start):
    pq = []
    heapq.heappush(pq, (0, start))
    # 누적 거리를 저장할 변수
    distance = [float('inf')] * (n + 1)
    distance[start] = 0

    while pq:
        d, now = heapq.heappop(pq)

        if distance[now] < d:
            continue

        for next_dist, next_node in graph[now]:
            if distance[next_node] > next_dist + d:
                distance[next_node] = next_dist + d
                # push 할때 next_dist + d 조심하자
                heapq.heappush(pq, (next_dist + d, next_node))

    return distance


# 정점갯수, 노드갯수
n, e = map(int, input().split())
# 인접 리스트
graph = [[] for _ in range(n+1)]


# 양방향 간선 정보 저장
for _ in range(e):
    s, e, w = map(int, input().split())
    graph[s].append([w, e])
    graph[e].append([w, s])

# 필수방문 정점
v1, v2 = map(int, input().split())

# 1번 정점에서 모든 정점까지의 최단 거리
distance_start = dijkstra(1)
# v1번 정점에서 모든 정점까지의 최단 거리
distance_v1 = dijkstra(v1)
# v2번 정점에서 모든 정점까지의 최단 거리
distance_v2 = dijkstra(v2)

# 1 → v1 → v2 → n
path1 = distance_start[v1] + distance_v1[v2] + distance_v2[n]
# 1 → v2 → v1 → n
path2 = distance_start[v2] + distance_v2[v1] + distance_v1[n]

result = min(path1, path2)

if result == float('inf'):
    print(-1)
else:
    print(result)
```
